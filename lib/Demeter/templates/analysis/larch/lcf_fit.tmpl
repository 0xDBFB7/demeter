{
  # here $S is the LCF group
  @list = $S->standards_list;
  $string = q{'} . $list[0] . q{',};
  $mix = join('', 'lcf.', shift(@list));
  foreach my $stan (@list) {
    $mix .= ' + ' . join('', 'lcf.', $stan);
    $string .= q{'} . $stan . q{',};
  };
  chop $string;
  q{};
}
##| set up the LCF objective function
i1 = index_of({$S->group}.x, {$S->xmin})
i2 = index_of({$S->group}.x, {$S->xmax})

def lcf_fit(par, par_sh, lcf):
    for x in ({$string}):
        ## amplitude/e0 parameters, bkg_eshift for this standard
        __a  = getattr(par,  x+'_a')
        __e  = getattr(par,  x+'_e')
        __sh = getattr(par_sh, x)
        if '{$S->space}' == 'chi':
            __grid = getattr(lcf, 'x')
            __kgri = getattr(_main.get_group(x), 'k')
            __data = getattr(_main.get_group(x), 'chi')
            __new  = __a * interp(__grid, __kgri, __data*__kgri**{$P->kweight})
        else:
            ## arrays for interpolation
            __grid = getattr(lcf, 'x')
            __ener = getattr(_main.get_group(x), 'energy')
            __data = getattr(_main.get_group(x), '{$S->suffix}')
            ## this standard, weighted, interpolated onto data grid
            __new  = __a * interp(__grid, __ener+__e+__sh, __data)
        endif
        setattr(lcf, x, __new)
    endfor
    lcf.lcf = {$mix}
    lcf.resid = lcf.lcf - lcf.func
    return lcf.resid[i1:i2]
enddef

##| perform the LCF fit
minimize(lcf_fit, demlcf, args=(demlcfsh, {$S->group}))
_sys.paramGroup = None
demlcf.rfactor = sum({$S->group}.resid[i1:i2]**2) / sum({$S->group}.func[i1:i2]**2)
