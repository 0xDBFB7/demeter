[% META title = 'File type plugins'
	about = 'Extending Athena to read new file types'
	difficult = 1
%]


[% WRAPPER html/todo %]
Move this page to the appropriate chapter.  Also resolve issues
surrounding user and system plugins .. do user plugins really exist?
[% END %]


[% FILTER html_para %]
[% athena %] uses [% ifeffit %]'s[%#'%]
[% INCLUDE html/link
	text='read_data()'
	link="http://cars9.uchicago.edu/~ifeffit/refman/node99.html" %]
function to import data. This means
that [% athena %]'s[%#'%] notion of what is an acceptable data format is
completely identical to [% ifeffit %]'s[%#'%] notion. The contrapositive is also
true -- if [% ifeffit %] can read a data file, so can [% athena %].

In practice, this works great. [% ifeffit %] is able to read the data files
generated by many of the world's[%#'%] XAS beamlines. And so, consequently,
is [% athena %]. Sadly, there are many beamlines that use a format that
confounds [% ifeffit %] and [% athena %]. There are two obvious ways that I
could deal with data from those beamline:
[% END %]

[% WRAPPER html/list type="ol" %]
[% WRAPPER html/li %]
Refuse to deal with them and require the user to transform the
data into a form that [% ifeffit %] can handle.
[% END %]
[% WRAPPER html/li %]
Hard-wire code into [% athena %] to deal with each new data format as I
become aware of it.
[% END %]
[% END %]

[% FILTER html_para %]
Neither of those are particularly user-friendly.  [%athena%] instead
relies on a plugin architecture allowing [%athena%] to be extended on
the fly to deal well with new data formats without having to change the
underlying code.

This page documents the plugin architecture so that [%athena%]'s[%#'%]
users can write their own file type plugins. 
[% END %]

[% PROCESS section label="Overview of how plugins work" %]
[% FILTER html_para %]
In simple language, a perl module is a short file containing special
perl code placed in a special location. [% athena %] uses the code
contained in that file to recognize and pre-process data files so that
they can be imported properly using [% ifeffit %].

In somewhat more technical language, a plugin is just
[% INCLUDE html/link
   text="a perl module"
   link="http://perldoc.perl.org/perlmod.html" %]
placed on your computer in a place where it can be found.
This file is used when [%athena%] starts and its methods are available
when data are imported.

When a plugin is available for use, it is invoked every time a file is
imported into [% athena %] using the Open file function. The new file
is checked using one of the plugin's[%#'%] methods to ascertain if the file
is of the sort serviced by the plugin. If the file is recognized,
another method in the plugin transforms the original data file into a
form that is readable by [% ifeffit %]. This transformation is done in a way
that leaves the original data file unchanged.

If the transformation is successful, the user is presented with
[% athena %]'s[%#'%] column selection dialog and can import data in the normal
manner. Ideally, a plugin is written in a way that makes the import of
the data into [% athena %] a completely transparent process for the user.
[% END %]


[% PROCESS section label="Example plugin" %]
[% FILTER html_para %]
Here is a complete example of a functional plugin taken from the
[% horae %] distribution.  This plugin allows [% athena %] to import
files from NSLS beamline X10C.  As you can see, the plugin is quite
short. The following sections of this page will explain this example
in detail.
[% END %]

[% SWITCH document_style %]

[% CASE 'latex' %]
[% WRAPPER codeexample -%]
[% INSERT "./src/other/plugin.example" %]
[% END %]

[% CASE 'latexbw' %]
[% USE PerlSyntaxLatexBw %]
[% WRAPPER html/perlblock %]
[% FILTER highlighter %]
[% INSERT "./src/other/plugin.example" %]
[% END %]
[% END %]

[% CASE 'html' %]
[% WRAPPER codeexample -%]
[% INSERT "./src/other/plugin.example" %]
[% END %]

[% CASE 'pod' %]
[% USE PerlSyntaxPod %]
[% WRAPPER html/perlblock %]
[% FILTER highlighter %]
[% INSERT "./src/other/plugin.example" %]
[% END %]
[% END %]

[% END %]

[% PROCESS section label="Namespace" %]
[% FILTER html_para %]
The module must be in a particular namespace. The namespace is defined
by the package function on line 1 of the example.  The package must be below the
[% PROCESS font/mono a="Demeter::Plugins" %]
namespace and should have a name that is descriptive of what format it
is made for.  In the case of the example, the plugin is intended to
transform files from NSLS beamline X10C, so the full namespace of the module is
[% PROCESS font/mono a="Demeter::Plugins::X10C"%].
Lines 3, 4, 62, and 63 are some requisite boilerplate which allow this module
to work properly with [%demeter%] and [%athena%].
[% END %]

[% PROCESS section label="Required methods and variables" %]
[% FILTER html_para %]
The plugin must supply three
methods and must set several attributes of the Plugin object.
[% END %]

[% PROCESS subsection label="required attributes" %]
[% FILTER html_para %]
Lines 12-14 define the two required variables in a way that allows
them to be accessed outside the scope of this module.
[% END %]

[% WRAPPER html/list type="dl" %]
[% WRAPPER html/dt dt="is_binary" %]
(Line 6) A boolean that tells [%athena%] whether the input file format
is in a text or binary format.  [%athena%] handles binary files slightly
differently in the column selection dialog.
[% END %]
[% WRAPPER html/dt dt="description" %]
(Line 7) A short text string describing the purpose of this plugin. This
string will be displayed in the plugin registry.  This description
should be no more than a few dozen characters.
[% END %]
[% WRAPPER html/dt dt="version" %]
(Line 8) This is a numeric version of the plugin.
[% END %]
[% WRAPPER html/dt dt="metadata_ini" %]
[% WRAPPER html/todo %]
(Line 9) Document this attribute once the meta data system is fleshed out
[% END %]
[% END %]
[% END %]

[% PROCESS subsection label="the is method" %]
[% FILTER html_para %]
Lines 12-23 show the [% PROCESS font/mono a="is" %]
method. This method is called by [% athena %]
to try to recognize an input data file as being of a particular
format. In the case of this example, the X10C file is recognized by
some of the text in the first few lines of the files.  When the file is
recognized, this method returns a true value.  If the test fails, it
returns 0.  When [%athena%] sees the true return value, it applies
the fix method to transform the data file into an [%ifeffit%]-friendly
format.

It is quite important that the is method be fast. It is possible that
a data file will have to be tested against a large number of
plugins.  If the is method is slow, file import will be slow.
[% END %]

[% PROCESS subsection label="the fix method" %]
[% FILTER html_para %]
Lines 26-46 show the [% PROCESS font/mono a="fix" %]
method.  This method is called when the is
method returns true.  In some manner it makes a copy of the original
data file and transforms that copy into a form that can be read by
[%ifeffit%].  This method needs to follow a number of strict rules,
however within those rules there is a lot of flexibility about how the
transformation is accomplished and the scope of what that
transformation does to the data.

First and most important, never alter the original data!  Either work
on the contaents of the original file in memory or make a copy of the
data, preferably in the stash folder (a folder known to [%demeter%] as
a place for writing scratch files).  At line 29, we see that file is
opened in the stash folder for holding the transformed data.  As t he
data is processed, the output is written to that file (see lines 36
and 40).

Do whatever chore needs doing to transform the portion of the
original data file that needs attention.  Afterwords close both the
input and output files.  It is esential that the files be closed,
particularly on Windows, which locks opened files from other uses.

Finally set the [% PROCESS font/mono a="fixed" %] attribute of the
object to the path and name of the transformed file and return that
same string.

In the example given on this page, the first thing the
[% PROCESS font/mono a="fix" %] method does
is to create a file name in the stash directory for the transformed
file. Line 28 tells [%athena%] to give the stash file the same name
as the original file (before calling this method,  [%athena%] sets the
[% PROCESS font/mono a="filename" %] attribute appropriately)
but in the stash directory (the catfile method builds a fully resolved
filename in a platform transparent manner).  Line 29 checks the length
of the fully resolved filename to avoid running into one of [% ifeffit %]'s[%#'%]
internal limitations.

Three things are done to transform an X10C file. The header is
stripped of null characters, the header is commented out by putting
[% hash %] characters in the first column, and a
formatting problem in some files involving a lack of white space
between columns is resolved.  Each line of the original file is read,
operated on, and written to the transformed file in the stash
directory. The while loop starting at line 34 reads through the file
line-by-line and performs the operations.

Lines 42 and 43 close the original and new file handles. The filter
should always close the file handles.  This is not such a huge issue
under unix, but Windows places a lock on any open file handle.  If you
fail to close one, for as long as [% athena %] is running no other process
will be able to do anything with that file.

At line 45, the method returns with the fully resolved name of the
transformed file. At no point was the original file altered. When
[% athena %] exits, it will clean up the stash directory, thus avoiding a
pile up of unnecessary data files.


[%demeter%] ships with a number of differnt kinds of plugins.  Some of
them perform simple, linear transofrmations (like this one).  Others
interpret binary data.  A couple export project files rather than data
files.  One even performs an on-the-fly deadtime correction for data
from an energy dispersive detector.  Examine them for hints about how
to create your own plugins.
[% END %]

[% PROCESS subsection label="the suggest method" %]
[% FILTER html_para %]
Lines 48-59 show the [% PROCESS font/mono a="suggest" %]
method.  This provides feedback for use by the 
[% INCLUDE html/link text="column selection dialog" link="columns.html" %]
is selecting initial guesses for the columns containing the numerator
and denominator of the data.  In this case, the method suggests
columns for transmission data butmakes no suggestions of fluorescence
data. 
[% END %]






[% PROCESS section label="Athena's plugin registry" %]
[% FILTER html_para %]

Because there might be a large number of file type plugins, it is
possible for the user to turn the checks for the file types on and
off. In the Settings menu, you will find the Plugin Registry.  This is
a simple list of all plugins found in the system and user directories.
The check buttons enable and disable the plugins. The value of the
[% PROCESS font/mono a="$description" %] variable is displayed in the
list (so be sure to choose a suitable and suitably short value for
that variable).
[% END %]

[% WRAPPER figure file="import_plugin.png" %]
[% athena %]'s[%#'%] plugin registry.
[% END %]

[% FILTER html_para %]
Note that the order in which the plugins are displayed
[% INCLUDE imageref text="above" label="import_plugin" in=1 %]
is the same order in which files are checked against the plugins. User
plugins are checked before system plugins.  After that the plugins are
ordered alphabetically. If you want your system plugins to be checked
against the data first, choose a name that comes early in the
alphabetical sense.

Right-clicking on an item in the registry posts the context menu shown
in the figure above.  All such context menus have at least one item
for reading the documentation contained in the plugin source code
file.  Some plugins, such as the one shown, also provide a way of
configuring the behavior of the plugin.
[% END %]


[% PROCESS section label="System plugins and user plugins" %]
[% FILTER html_para %]

[% athena %] looks in two different places for these plugins. One place is
in [% athena %]'s[%#'%] installation location where it finds the plugins that come
with the horae distribution. The other is in the user's[%#'%] space
(on Windows plugins are located in
[% PROCESS font/file a="C:\\Program
File\\Ifeffit\\horae\\Ifeffit\\Plugins\\Filetype\\Athena\\" %],
on unix [% PROCESS font/file a="\$HOME/.horae/Ifeffit/Plugins/Filetype/Athena/" %]).
In both places, it reads the contents of the plugin directory and
attempts to import the files which end in
[% PROCESS font/file a=".pm" %].

[% END %]

[% PROCESS section label="Miscellaneous advice on plugins" %]
[% WRAPPER html/list type="ol" %]
[% WRAPPER html/li %]
Cut-n-paste is an excellent way to get started on a new
plugin. Make a copy of a plugin for a file that is similar to
your own file and use that as the basis for your new plugin.
[% END %]
[% WRAPPER html/li %]
[% PROCESS font/file a="X15B.pm" %] is an example of a plugin
for a binary format.
[% END %]
[% WRAPPER html/li %]
You can use any module that you need, thus you have all of CPAN
available to you when designing your plugin. If you need to do
any seriously heavy lifting, check out the
[% PROCESS font/mono a="Math::Pari" %] module or
the [% PROCESS html/link text="Perl Data Language"
link="http://pdl.perl.org" %]
[% END %]
[% WRAPPER html/li %]
Although a well-tested, robust plugin should be your goal, one of
the nice features of the plugin architecture is that a
[% INCLUDE font/quote a="good-enough" %] plugin is easy to write
and can quickly get you over a hurdle.
[% END %]
[% END %]
