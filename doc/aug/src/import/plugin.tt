[% META title = 'File type plugins'
	about = 'Extending Athena to read new file types'
	difficult = 1
%]


[% WRAPPER html/todo %]
Move this page to the appropriate chapter
[% END %]


[% FILTER html_para %]
[% athena %] uses [% ifeffit %]'s
[% INCLUDE html/link
	text='read_data()'
	link="http://cars9.uchicago.edu/~ifeffit/refman/node99.html" %]
function to import data. This means
that [% athena %]'s notion of what is an acceptable data format is
completely identical to [% ifeffit %]'s notion. The contrapositive is also
true -- if [% ifeffit %] can read a data file, so can [% athena %].

In practice, this works great. [% ifeffit %] is able to read the data files
generated by many of the world's XAS beamlines. And so, consequently,
is [% athena %]. Sadly, there are many beamlines that use a format that
confounds [% ifeffit %] and [% athena %]. There are three reasonable ways that I
could deal with deal data from those beamline:
[% END %]

[% WRAPPER html/list type="ol" %]
[% WRAPPER html/li %]
Refuse to deal with them and require the user to transform the
data into a form that [% ifeffit %] can handle.
[% END %]
[% WRAPPER html/li %]
Hard-wire code into [% athena %] to deal with each new data format as I
become aware of it.
[% END %]
[% WRAPPER html/li %]
Create a plugin architecture that allows [% athena %] to be extended
to deal well with new data formats without having to change the
underlying code.
[% END %]
[% END %]

[% FILTER html_para %]
For a long time, [% athena %] relied on a combination of 1 and 2 from
that list. Eventually I decided to adopt number 3.  This page
documents the plugin architecture so that [% athena %]'s users can
begin writing their own file type plugins.
[% END %]

[% PROCESS section label="Overview of how plugins work" %]
[% FILTER html_para %]
In simple language, a perl module is a short file containing special
perl code placed in a special location. [% athena %] uses the code
contained in that file to recognize and pre-process data files so that
they can be imported properly using [% ifeffit %].

In somewhat more technical language plugin is just
[% INCLUDE html/link
   text="a perl module"
   link="http://perldoc.perl.org/perlmod.html" %]
placed on your computer in a place where it can be found.
This file is used when [% athena %] starts and its methods are available
when data is imported.

When a plugin is available for use, it is invoked every time a file is
imported into [% athena %] using the Open file function. The new file
is checked using one of the plugin's methods to ascertain if the file
is of the sort serviced by the plugin. If the file is recognized,
another method in the plugin transforms the original data file into a
form that is readable by [% ifeffit %]. This transformation is done in a way
that leaves the original data file unchanged.

If the transformation is successful, the user is presented with
[% athena %]'s column selection dialog and can import data in the normal
manner. Ideally, a plugin is written in a way that makes the import of
the data into [% athena %] a completely transparent process for the user.
[% END %]


[% PROCESS section label="Example plugin" %]
[% FILTER html_para %]
Here is a complete example of a functional plugin taken from the
[% horae %] distribution.  This plugin allows [% athena %] to import
files from NSLS beamline X10C.  As you can see, the plugin is quite
short. The following sections of this page will explain this example
in detail.
[% END %]

[% SWITCH document_style %]

[% CASE 'latex' %]
[% USE PerlSyntaxLatex %]
[% WRAPPER html/perlblock %]
[% FILTER highlighter %]
[% INSERT "./templates/src/import/plugin.example" %]
[% END %]
[% END %]

[% CASE 'latexbw' %]
[% USE PerlSyntaxLatexBw %]
[% WRAPPER html/perlblock %]
[% FILTER highlighter %]
[% INSERT "./templates/src/import/plugin.example" %]
[% END %]
[% END %]

[% CASE 'html' %]
[% USE PerlSyntaxHtml %]
[% WRAPPER html/perlblock %]
[% FILTER html_line_break %]
[% FILTER highlighter %]
[% INSERT "./templates/src/import/plugin.example" %]
[% END %]
[% END %]
[% END %]

[% CASE 'pod' %]
[% USE PerlSyntaxPod %]
[% WRAPPER html/perlblock %]
[% FILTER highlighter %]
[% INSERT "./templates/src/import/plugin.example" %]
[% END %]
[% END %]

[% END %]

[% PROCESS section label="Namespace" %]
[% FILTER html_para %]
The module must be in a particular namespace. The namespace is defined
by the package function on line 2 of the example. The convention for
the namespace used by the plugin is slightly unwieldy, but was chosen
for a good reason. The package must be in the
[% PROCESS font/mono a="Ifeffit::Plugins::Filetype::Athena" %]
namespace and should have a name that is descriptive of what format it
is made for. in the case of the example, the plugin is intended to
transform X10C files, so the full namespace of the module is
[% PROCESS font/mono a="Ifeffit::Plugins::Filetype::Athena::X10C"%].
Lines 4-9 include requisite boilerplate which will allow this module
to work properly with [% athena %] and call some modules that are
almost always useful.

The reason I chose such an unwieldy namespace is to allow for the
possibility of moving much functionality in both [% athena %] and
[% artemis %] into the form of plugins. With this choice, I will have
considerable flexibility without having to rewrite any existing code.
[% END %]

[% PROCESS section label="Required methods and variables" %]
[% FILTER html_para %]
The plugin must supply two [% INCLUDE font/quote a="public" %]
variables and two [% INCLUDE font/quote a="public" %]
methods. (I put public in quotes because, of course, perl modules
constructed like our plugins do not provide true encapsulation of
variables and methods.  The sense in which I mean public is that
[% athena %] requires certain variables and methods in the namespace
of the plugin. Without them, the plugin will fail noisily.)
[% END %]

[% PROCESS subsection label="required variables" %]
[% FILTER html_para %]
Lines 12-14 define the two required variables in a way that allows
them to be accessed outside the scope of this module.
[% END %]

[% WRAPPER html/list type="dl" %]
[% WRAPPER html/dt dt="\$is_binary" %]
A boolean that tells [% athena %] whether the input file format
is text or binary. [% athena %] handles binary files slightly
differently in the column selection dialog.
[% END %]
[% WRAPPER html/dt dt="\$description" %]
A short text string describing the purpose of this plugin. This
string will be displayed in the plugin registry -- take a look at
the amount of space available there, and make your string shorter
than that.
[% END %]
[% END %]

[% PROCESS subsection label="the is method" %]
[% FILTER html_para %]
Lines 17-30 show the [% PROCESS font/mono a="is" %]
method. This method is called by [% athena %]
to try to recognize an input data file as being of a particular
format. In the case of this example, the X10C file is recognized by
some of the text in the first few lines of the files. When the file is
recognized, this method returns a true value. If the test fails, it
returns 0. When [% athena %] sees the true return value, it applies
the fix method to transform the data file.

It is quite important that the is method be fast. It is possible that
a data file will have to be tested against a large number of
plugins. If the is method is slow, file import will be slow.
[% END %]

[% PROCESS subsection label="the fix method" %]
[% FILTER html_para %]
Lines 33-54 show the [% PROCESS font/mono a="fix" %]
method. This method is called when the is
method returns true. In some manner it makes a copy of the original
data file and transforms that copy into a form that can be read by
[% ifeffit %]. This method needs to follow a number of strict rules,
however within those rules there is a lot of flexibility about how the
transformation is accomplished and the scope of what that
transformation does to the data.

This method takes four scalars as inputs.
[% END %]

[% WRAPPER html/list type="dl" %]
[% WRAPPER html/dt dt="\$data" %]
This is a string containing the fully resolved name of the input
data file.
[% END %]
[% WRAPPER html/dt dt="\$stash_dir" %]
This is a string with the location where [% athena %] will look for the
transformed copy of the data.
[% END %]
[% WRAPPER html/dt dt="\$top" %]
This is a reference to [% athena %]'s main window. This allows you to
create a GUI input dialog to collect information interactively
from the user.  See the Encoder plugin for an example of how this
is used.
[% END %]
[% WRAPPER html/dt dt="\$r_hash" %]
This is a reference to a hash that can contain information about
how the data are transformed.  This hash persists between
invocations of the fix method, thus allowing you to reuse
parameters about the transformation.  Again, see the Encoder
plugin for an example of how this is used.
[% END %]
[% END %]

[% FILTER html_para %]
The return value of this method is the fully resolved file name of the
transformed file which must be located in the directory indicated in
the [% PROCESS font/mono a="\$stash_dir" %] input scalar.

The basic work flow of the fix method is to open the original data
file, perform some kind of operation on the data, and write the
transformed data to the [% PROCESS font/mono a="\$stash_dir" %].
This can be done almost any way. Some plugins use [% ifeffit %] commands
(via the [% PROCESS font/mono a="Ifeffit module" %])
to operate on the data. Other plugins use pure perl to parse and
transform the file.

In the example given on this page, the first thing the
[% PROCESS font/mono a="fix" %] method does
is to create a file name in the stash directory for the transformed
file. Lines 36 and 37 tell [% athena %] to give the stash file the same name
as the original file (that is the function of the
[% PROCESS font/mono a="fileparse" %] command)
but in the stash directory (the catfile method builds a fully resolved
filename in a platform transparent manner). Line 38 checks the length
of the fully resolved filename to avoid running into one of [% ifeffit %]'s
internal limitations.

Three things are done to transform an X10C file. The header is
stripped of null characters, the header is commented out by putting
[% hash %] characters in the first column, and a
formatting problem in some files involving a lack of white space
between columns is resolved. Each line of the original file is read,
operated on, and written to the transformed file in the stash
directory. The while loop starting at line 43 reads through the file
line-by-line and performs the operations.

Lines 51 and 52 close the original and new file handles. The filter
should always close the file handles.  This is not such a huge issue
under unix, but Windows places a lock on any open file handle.  If you
fail to close one, for as long as [% athena %] is running no other process
will be able to do anything with that file.

At line 53, the method returns with the fully resolved name of the
transformed file. At no point was the original file altered. When
[% athena %] exits, it will clean up the stash directory, thus avoiding a
pile up of unnecessary data files.

The work flow in this example is a simple stream from one file to
another. Other filters ([% PROCESS font/file a="Lambda.pm" %] is an
example) in the [% horae %] distribution use [% ifeffit %] to perform the
transformation.  [% PROCESS font/file a="X15B.pm" %] uses perl's
[% INCLUDE html/link text="pack function"
		     link="http://perldoc.perl.org/functions/pack.html" %]
to transform a binary file. [% PROCESS font/file a="Encoder.pm" %]
generates a simple GUI dialog to get data necessary for the
transformation from the user. As you can see, the architecture of these
plugins is quite flexible, allowing you to solve the transformation
problem in whatever manner best suits the situation.

[% END %]




[% PROCESS section label="Athena's plugin registry" %]
[% FILTER html_para %]

Because there might be a large number of file type plugins, it is
possible for the user to turn the checks for the file types on and
off. In the Settings menu, you will find the Plugin Registry.  This is
a simple list of all plugins found in the system and user directories.
The check buttons enable and disable the plugins. The value of the
[% PROCESS font/mono a="$description" %] variable is displayed in the
list (so be sure to choose a suitable and suitably short value for
that variable).
[% END %]

[% WRAPPER figure file="import_plugin.png" %]
[% athena %]'s plugin registry.
[% END %]

[% FILTER html_para %]
Note that the order in which the plugins are displayed
[% INCLUDE imageref text="above" label="import_plugin" in=1 %]
is the same order in which files are checked against the plugins. User
plugins are checked before system plugins. After that the plugins are
ordered alphabetically. If you want your system plugins to be checked
against the data first, choose a name that comes early in the
alphabetical sense.
[% END %]

[% PROCESS section label="Reformatting and data processing" %]
[% FILTER html_para %]
When I originally conceived the concept of the file type plugins, the
scope was for the problem of importing data in a format not recognized
by [% ifeffit %]. The plugins can also be used for some data
processing.  For instance, you might do deadtime corrections using the
ICR and OCR columns of an MED file using a plugin.  In that case, the
fix method would perform the deadtime correction as the data is
streamed between the original file and the stash directory.

Another example of pre-processing is the filter I wrote for
[% INCLUDE html/link
	text="MED files from APS Sector 10"
	link="http://wiki.mr.aps.anl.gov/AnalysisSoftware/ReadingMedFilesWithAthena" %].
We try to run in a mode where dead time is negligible. However, the
large number of columns tends to use way to much of [% ifeffit %]'s
memory, thus slowing [% athena %] way down. A good solution to
that problem was to use a plugin to strip all the unused columns,
leaving only the ROI columns in file in the stash directory. Note that
the Sector 10 plugin is an example of using a plugin to alter a file
that [% athena %] could already read, but in a way that adds value to
the user's interaction with [% athena %].

[% END %]

[% PROCESS section label="System plugins and user plugins" %]
[% FILTER html_para %]

[% athena %] looks in two different places for these plugins. One place is
in [% athena %]'s installation location where it finds the plugins that come
with the horae distribution. The other is in the user's space
(on Windows plugins are located in
[% PROCESS font/file a="C:\\Program
File\\Ifeffit\\horae\\Ifeffit\\Plugins\\Filetype\\Athena\\" %],
on unix [% PROCESS font/file a="\$HOME/.horae/Ifeffit/Plugins/Filetype/Athena/" %]).
In both places, it reads the contents of the plugin directory and
attempts to import the files which end in
[% PROCESS font/file a=".pm" %].

[% END %]

[% PROCESS section label="Miscellaneous advice on plugins" %]
[% WRAPPER html/list type="ol" %]
[% WRAPPER html/li %]
Cut-n-paste is an excellent way to get started on a new
plugin. Make a copy of a plugin for a file that is similar to
your own file and use that as the basis for your new plugin.
[% END %]
[% WRAPPER html/li %]
[% PROCESS font/file a="X15B.pm" %] is an example of a plugin
for a binary format.
[% END %]
[% WRAPPER html/li %]
[% PROCESS font/file a="Encoder.pm" %] is an example of a plugin
that uses both GUI elements and the persistent hash.
[% END %]
[% WRAPPER html/li %]
[% PROCESS font/file a="Lambda.pm" %] is an example of using
[% ifeffit %] to perform the transformation. (Simply
[% INCLUDE font/mono a="use Ifeffit qw(ifeffit);" %]
near line 5, then make use of the
[% PROCESS font/mono a="ifeffit" %] function in the fix method.)
[% END %]
[% WRAPPER html/li %]
You can use any module that you need, thus you have all of CPAN
available to you when designing your plugin. If you need to do
any seriously heavy lifting, check out the
[% PROCESS font/mono a="Math::Pari" %] module or
the [% PROCESS html/link text="Perl Data Language"
link="http://pdl.perl.org" %]
[% END %]
[% WRAPPER html/li %]
Although a well-tested, robust plugin should be your goal, one of
the nice features of the plugin architecture is that a
[% INCLUDE font/quote a="good-enough" %] plugin is easy to write
and can quickly get you over a hurdle.
[% END %]
[% END %]
