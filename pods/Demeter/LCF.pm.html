<!DOCTYPE html>
<html lang="en" xml:lang="en">
<head>
<title>Demeter::LCF &mdash; Demeter</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><link rel="stylesheet" href="../podstyle.css" type="text/css" />
</head>
<body><div class="box">
  <h1 class="t1">Demeter</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">Perl tools for X-ray Absorption Spectroscopy</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../index.html">Demeter</a> &gt; Perl Modules &gt;
  Demeter::LCF
</div>
<div>

<a href="../src/Demeter/LCF.pm">Source</a>

</div>

<div class="pod">


<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#ATTRIBUTES">ATTRIBUTES</a>
    <ul>
      <li><a href="#Parameters-of-the-fit">Parameters of the fit</a></li>
      <li><a href="#Standards">Standards</a></li>
      <li><a href="#Statistics">Statistics</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a></li>
  <li><a href="#COMBINATORIAL-FITTING">COMBINATORIAL FITTING</a>
    <ul>
      <li><a href="#Attributes-for-combinatorial-fitting">Attributes for combinatorial fitting</a></li>
      <li><a href="#Methods-of-combinatorial-fitting">Methods of combinatorial fitting</a></li>
    </ul>
  </li>
  <li><a href="#SEQUENCE-FITTING">SEQUENCE FITTING</a>
    <ul>
      <li><a href="#Attributes-for-combinatorial-fitting1">Attributes for combinatorial fitting</a></li>
      <li><a href="#Methods-of-sequence-fitting">Methods of sequence fitting</a></li>
    </ul>
  </li>
  <li><a href="#SERIALIZATION-AND-DESERIALIZATION">SERIALIZATION AND DESERIALIZATION</a></li>
  <li><a href="#CONFIGURATION-AND-ENVIRONMENT">CONFIGURATION AND ENVIRONMENT</a></li>
  <li><a href="#DEPENDENCIES">DEPENDENCIES</a></li>
  <li><a href="#BUGS-AND-LIMITATIONS">BUGS AND LIMITATIONS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#LICENCE-AND-COPYRIGHT">LICENCE AND COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Demeter::LCF - Linear combination fitting</p>

<h1 id="VERSION">VERSION</h1>

<p>This documentation refers to Demeter version 0.9.26.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>   #!/usr/bin/perl
   use Demeter;

   my $prj  = Demeter::Data::Prj -&gt; new(file=&gt;&#39;examples/cyanobacteria.prj&#39;);
   my $lcf  = Demeter::LCF -&gt; new;
   my $data = $prj-&gt;record(4);
   my ($metal, $chloride, $sulfide) = $prj-&gt;records(9, 11, 15);

   $lcf -&gt; data($data);
   $lcf -&gt; add($metal);
   $lcf -&gt; add($chloride);
   $lcf -&gt; add($sulfide);

   $lcf -&gt; xmin($data-&gt;bkg_e0-20);
   $lcf -&gt; xmax($data-&gt;bkg_e0+60);
   $lcf -&gt; po -&gt; set(emin=&gt;-30, emax=&gt;80);
   $lcf -&gt; fit;
   $lcf -&gt; plot_fit;
   $lcf -&gt; save(&#39;lcf_fit_result.dat&#39;);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Linear combination fitting (LCF) is an analysis method for interpreting XANES or EXAFS data using standards. The assumption is that the data from an unknown sample can be understood as a linear superposition of the data from two or more known, well-understood standards. The LCF analysis, therefore, tells us what fraction of the unknown sample is explained by one of the known standards.</p>

<p>For example, imagine mixing together quantities of iron oxide and iron sulfide such that there are equal numbers of iron atoms surrounded by oxygen and by sulfur. You would then expect to be able to describe the data from the mixure by adding together equal parts of the data from the two pure materials.</p>

<p>This object provides a framework for performing this sort of analysis. In the example shown above, data and standards are imported from an Athena project file. The data are fit as a linear combination of three standards. The result of the fit is the fraction of each standard present in the data as well as uncertainties in those fractions.</p>

<p>This object also provides methods for &quot;combinatorial fitting&quot;. In this approach an ensemble of standards are compared to the data in all possible combinations (with certain constraints). The results are sorted by increasing R-factor of the fit. The first result, then, is the combination of standards giving the closest fit to the data.</p>

<h1 id="ATTRIBUTES">ATTRIBUTES</h1>

<h2 id="Parameters-of-the-fit">Parameters of the fit</h2>

<dl>

<dt id="xmin"><code>xmin</code></dt>
<dd>

<p>The lower bound of the fit. For a fit to the normalized or derivative mu(E), this is an absolute energy value and <b>not</b> relative to the edge energy.</p>

</dd>
<dt id="xmax"><code>xmax</code></dt>
<dd>

<p>The upper bound of the fit. For a fit to the normalized or derivative mu(E), this is an absolute energy value and <b>not</b> relative to the edge energy.</p>

</dd>
<dt id="space"><code>space</code></dt>
<dd>

<p>The fitting space. This can be one of <code>nor</code>, <code>der</code>, or <code>chi</code>. When fitting in <code>chi</code>, e0 cannot be varied.</p>

</dd>
<dt id="max_standards"><code>max_standards</code></dt>
<dd>

<p>The maximum number of standards to use in each fit of a combinatorial sequence.</p>

</dd>
<dt id="include_caller"><code>include_caller</code></dt>
<dd>

<p>A boolean. Use in sequence fitting to determine whether the data currently associated with the LCF object is inlcuded in the fit sequence. The default is true. This is a convenience introduced for the sake of the LCF tool in Athena.</p>

</dd>
<dt id="linear"><code>linear</code></dt>
<dd>

<p>A boolean. When true, add a linear term to the fit. (Not implemented yet.)</p>

</dd>
<dt id="inclusive"><code>inclusive</code></dt>
<dd>

<p>A boolean. When true, all weights are forced to be between 0 and 1 inclusive.</p>

</dd>
<dt id="unity"><code>unity</code></dt>
<dd>

<p>A boolean. When true, the weights are forced to sum to 1.</p>

</dd>
<dt id="one_e0"><code>one_e0</code></dt>
<dd>

<p>A boolean. When true, one over-all e0 parameter is used in the fit rather than one for each standard. In practice, the standards are shifted by the same floated e0 value. That is, one parameter is floated and an e0 for each standard is def-ed to that value.</p>

</dd>
<dt id="noise"><code>noise</code></dt>
<dd>

<p>If non-zero, add artifical noise to the data. The value is used as the sigma of the normally distributed artifical noise. You may need to play around to find an appropriate value for your data. Note that for a fit in chi(k), the noise is added to the un-k-weighted chi(k) data.</p>

</dd>
<dt id="kweight"><code>kweight</code></dt>
<dd>

<p>The kweighting used in a fit using chi(k) data.</p>

</dd>
<dt id="plot_components"><code>plot_components</code></dt>
<dd>

<p>A boolean. When true, the scaled components of the fit will be included in a plot.</p>

</dd>
<dt id="plot_difference"><code>plot_difference</code></dt>
<dd>

<p>A boolean. When true, the residual of the fit will be included in a plot.</p>

</dd>
<dt id="plot_indicators"><code>plot_indicators</code></dt>
<dd>

<p>A boolean. When true, plot indicators will mark the boundaries of the fit in a plot.</p>

</dd>
</dl>

<h2 id="Standards">Standards</h2>

<dl>

<dt id="standards"><code>standards</code></dt>
<dd>

<p>This attribute contains the list of standards added to this LCF problem. The accessor returns a list reference:</p>

<pre><code>  $ref_to_standards = $lcf-&gt;standards;</code></pre>

<p>It is strongly recommended that you do not assign standards directly to this. Instead use the <code>add</code> or <code>add_many</code> methods. Those methods take care of some other chores required to keep the LCF organized.</p>

</dd>
</dl>

<p>A number of methods are provided by Moose for interacting with the list stored in this attribute:</p>

<dl>

<dt id="push_standards"><code>push_standards</code></dt>
<dd>

<p>Push a value to the list.</p>

</dd>
<dt id="pop_standards"><code>pop_standards</code></dt>
<dd>

<p>Pop a value from the list.</p>

</dd>
<dt id="shift_standards"><code>shift_standards</code></dt>
<dd>

<p>Shift a value from the list.</p>

</dd>
<dt id="unshift_standards"><code>unshift_standards</code></dt>
<dd>

<p>Unshift a value to the list.</p>

</dd>
<dt id="clear_standards"><code>clear_standards</code></dt>
<dd>

<p>Assign an empty list.</p>

</dd>
</dl>

<h2 id="Statistics">Statistics</h2>

<p>Once the fit finishes, each of the following attributes is filled with a value appropriate to recently completed fit.</p>

<dl>

<dt id="nstan"><code>nstan</code></dt>
<dd>

<p>The number of standars used in the fit.</p>

</dd>
<dt id="npoints"><code>npoints</code></dt>
<dd>

<p>The number of data points included in the fit.</p>

</dd>
<dt id="nvarys"><code>nvarys</code></dt>
<dd>

<p>The number of variable parameters used in the fit.</p>

</dd>
<dt id="rfactor"><code>rfactor</code></dt>
<dd>

<p>An R-factor for the fit. For fits to chi(k) or the derivative spectrum, this is a normal R-factor in Ifeffit or Larch:</p>

<pre><code>   sum( [data_i - fit_i]^2 ]
  --------------------------
      sum ( data_i^2 )</code></pre>

<p>For a fit to normalized mu(E), that formulation for an R-factor always results in a really tiny number. Demeter thus scales the R-factor to make it somewhat closer to 10^-2.</p>

<pre><code>    npoints * sum( [data_i - fit_i]^2 ]
  ---------------------------------------
        sum ( [data_i - &lt;data&gt;]^2 )</code></pre>

<p>where &lt;data&gt; is the geometric mean of the data in the fitting range.</p>

</dd>
<dt id="chisqr"><code>chisqr</code></dt>
<dd>

<p>This is the chi-square for the fit.</p>

</dd>
<dt id="chinu"><code>chinu</code></dt>
<dd>

<p>This is the reduced chi-square for the fit.</p>

</dd>
</dl>

<h1 id="METHODS">METHODS</h1>

<dl>

<dt id="add"><code>add</code></dt>
<dd>

<p>Add a Data object to the LCF object for use one of the fitting standards. In it&#39;s simplest form, the sole argument is a Data objectL</p>

<pre><code>  $lcf -&gt; add($data_object);</code></pre>

<p>You can also set certain parameters of the standard by supplying an optional anonymous hash:</p>

<pre><code>  $lcf -&gt; add($data_object, required =&gt; 0,
                            float_e0 =&gt; 0,
                            weight   =&gt; 1/3,
                            e0       =&gt; 1/3,);</code></pre>

<p>The <code>required</code> parameter flags this standard as one that is required to be in a combinatorial fit. <code>float_e0</code> is true when you wish to float an energy shift for this standard. The other two are used to specify the weight and e0.</p>

<p>There are methods (described) below for setting each of these parameters.</p>

</dd>
<dt id="add_many"><code>add_many</code></dt>
<dd>

<p>This method provides a way of setting a group of Data objects as standard in one shot. It is equivalent to repeated calls to the <code>add</code> method without the anonymous hash.</p>

<pre><code>  $lcf -&gt; add_many(@data);</code></pre>

</dd>
<dt id="float_e0"><code>float_e0</code></dt>
<dd>

<p>This method is used to turn a floating e0 value on or off for a given standard.</p>

<pre><code>  $lcf-&gt;float_e0($standard, $onoff);</code></pre>

<p>The first argument is the standard in question, the second is a boolean toggling the floating e0 on or off.</p>

<p>These are the same:</p>

<pre><code>  $lcf-&gt;add($data);
  $lcf-&gt;float_e0($data, 1);</code></pre>

<p>and</p>

<pre><code>  $lcf-&gt;add($add, float_e0=&gt;1);</code></pre>

</dd>
<dt id="required"><code>required</code></dt>
<dd>

<p>This method is used to require a given standard in a combinatorial fit.</p>

<pre><code>  $lcf-&gt;required($standard, $onoff);</code></pre>

<p>The first argument is the standard in question, the second is a boolean toggling the requirement on or off.</p>

<p>These are the same:</p>

<pre><code>  $lcf-&gt;add($data);
  $lcf-&gt;required($data, 1);</code></pre>

<p>and</p>

<pre><code>  $lcf-&gt;add($add, required=&gt;1);</code></pre>

</dd>
<dt id="weight"><code>weight</code></dt>
<dd>

<p>This method is both a setter and getter of the weight for a given standard. As a getter:</p>

<pre><code>  my ($weight, $dweight) = $lcf-&gt;weight($standard);</code></pre>

<p>The weight and the uncertainty in the weight are returned as an array.</p>

<p>The weight can be set to an explicit value:</p>

<pre><code>  my ($weight, $dweight) = $lcf-&gt;weight($standard, $value);</code></pre>

<p>Again weight and the uncertainty in the weight are returned as an array. The uncertainty is zeroed when the weight is explicitly set.</p>

<p>In scalar context, this just returns the weight.</p>

</dd>
<dt id="e0"><code>e0</code></dt>
<dd>

<p>This method is both a setter and getter of the e0 shift for a given standard. As a getter:</p>

<pre><code>  my ($e0, $e0) = $lcf-&gt;e0($standard);</code></pre>

<p>The e0 and the uncertainty in the e0 are returned as an array.</p>

<p>The e0 can be set to an explicit value:</p>

<pre><code>  my ($e0, $de0) = $lcf-&gt;e0($standard, $value);</code></pre>

<p>Again e0 and the uncertainty in the e0 are returned as an array. The uncertainty is zeroed when the e0 is explicitly set.</p>

<p>In scalar context, this just returns the e0.</p>

</dd>
<dt id="fit"><code>fit</code></dt>
<dd>

<p>Perform the fit.</p>

<pre><code>  $lcf-&gt;fit;</code></pre>

<p>This will perform some sanity checks, including verifying that the data has been set and that at least two standards have been defined. It will also make sure <code>xmin</code> and <code>xmax</code> are in the correct order.</p>

<p>An optional boolean argument turns the spinner off when in screen UI mode. This allows use of a counter for combinatorial fits.</p>

<pre><code>  $lcf-&gt;fit(1);  # true value means to turn spinner off</code></pre>

</dd>
<dt id="report"><code>report</code></dt>
<dd>

<p>This returns a summary of the fitting results.</p>

<pre><code>  print $lcf-&gt;report;</code></pre>

</dd>
<dt id="save"><code>save</code></dt>
<dd>

<p>This method saves the results of a fit to a column data file containing columns for the x-axis (energy or wavenumber), the data, the fit, and each of the weighted components.</p>

<pre><code>  $lcf -&gt; save(&quot;file.dat&quot;);</code></pre>

</dd>
<dt id="plot_fit"><code>plot_fit</code></dt>
<dd>

<p>This method will generate a plot showing the data and the fit.</p>

<pre><code>  $lcf -&gt; plot_fit;</code></pre>

<p>The <code>plot_difference</code>, <code>plot_components</code>, and <code>plot_indicators</code> attributes determine whether the residual, the weighted components, and indicators marking the fitting range are included in the plot.</p>

<p>By default, the chi(k) and derivative components are stacked automatically.</p>

</dd>
<dt id="plot"><code>plot</code></dt>
<dd>

<p>This is the generic plotting method for use when overplotting a large number of objects. In this example, the data, the standards, and the result of the LCF fit are plotted together with the standards plotted normally rather than as the weighted components of the fit.</p>

<pre><code>   $lcf-&gt;po-&gt;start_plot;
   $lcf-&gt;po-&gt;set(e_norm=&gt;1, e_der=&gt;1, emin=&gt;-30, emax=&gt;70);
   $_-&gt;plot(&#39;e&#39;) foreach ($data, @standards, $lcf);</code></pre>

<p>This method does nothing (i.e. it does not attempt to plot the LCF fit at all) if the plot conditions do not match the fitting space of the fit. E.g., an LCF fit to normalized data will only be plotted if the fit is in energy and the <code>e_norm</code> Plot attribute is true.</p>

</dd>
<dt id="clean"><code>clean</code></dt>
<dd>

<p>This method clears all scalars and arrays out of the memory of the data processing backend (Ifeffit/Larch).</p>

<pre><code>  $lcf-&gt;clean;</code></pre>

</dd>
</dl>

<p>Note that there is not a <code>remove</code> method to do the opposite of <code>add</code>. This seems to me unnecessarily difficult to use. I suggest explicitly clearing the standards list and then <code>add</code>ing a new set of standards. This is how the combinatorial fitting loop works.</p>

<pre><code>  $lcf-&gt;add(@data);
   ... do stuff, then
  $lcf-&gt;clear_standards;
  $lcf-&gt;add(@new_data);</code></pre>

<p>Explain these:</p>

<pre><code>                                  &#39;push&#39;    =&gt; &#39;push_standards&#39;,
                                  &#39;pop&#39;     =&gt; &#39;pop_standards&#39;,
                                  &#39;shift&#39;   =&gt; &#39;shift_standards&#39;,
                                  &#39;unshift&#39; =&gt; &#39;unshift_standards&#39;,
                                  &#39;clear&#39;   =&gt; &#39;clear_standards&#39;,</code></pre>

<h1 id="COMBINATORIAL-FITTING">COMBINATORIAL FITTING</h1>

<p>These attributes and methods are specifically related to combinatorial fitting. A combinatorial fit is one in which all possible combinations (within certain constraints) are compared to the data.</p>

<h2 id="Attributes-for-combinatorial-fitting">Attributes for combinatorial fitting</h2>

<dl>

<dt id="max_standards1"><code>max_standards</code></dt>
<dd>

<p>The maximum number of standards to use in each fit of a combinatorial sequence. Note that the size of the combinatorial problem grows geometrically in the value of this parameter and in the number of possible standards.</p>

<p>If, for example, this is set to 4, then in a combinatorial fit, all possible combinations of 2, 3, or 4 standards will be fit to the data.</p>

<p>Note that the size of the combinatorial problem gets very large as this number grows.</p>

</dd>
<dt id="combi_results"><code>combi_results</code></dt>
<dd>

<p>This is an array of hashes, sorted by rfactor, containing all the results of fitting sequence.</p>

<p>Each hash in the array looks like this:</p>

<pre><code>  {
   Rfactor =&gt; Num,
   Chinu   =&gt; Num,
   Chisqr  =&gt; Num,
   Nvarys  =&gt; Num,
   Scaleby =&gt; Num,
   aaaaa   =&gt; [weight, dweight, e0, de0],
   bbbbb   =&gt; [weight, dweight, e0, de0],
   ....
  }</code></pre>

<p>A key like &quot;aaaaa&quot; is the group attribute of a Data object used in the fit. From this, the final state of each fit can be recovered using the <code>restore</code> method.</p>

</dd>
</dl>

<h2 id="Methods-of-combinatorial-fitting">Methods of combinatorial fitting</h2>

<dl>

<dt id="combi"><code>combi</code></dt>
<dd>

<p>Perform a combinatorial sequence of fits, that is, perform all fits using all combinations of standards up to the number in <code>max_standards</code>. If <code>max_standards</code> is 4, then all combinations of 2, 3, or 4 of all the standards added to the object will considered.</p>

<pre><code>  $lcf-&gt;combi;</code></pre>

<p>At the end of the fit, the <code>combi_results</code> attribute is filled with an array of hashes containing the sorted results of the fit. The first item in the array contains th results from the fit with the lowest R-factor (that is, the combinationof standards that most closely describes the data).</p>

<p>One or more standards can be flagged as being required in a fit. That is, each fit will include the flagged standards. This will significantly reduce the size of the combinatorial problem. See the discussion of the <code>add</code>, <code>required</code>, and <code>is_required</code> methods above.</p>

<p>At the end of the combinatorial sequence of fits, the fit with the lowest R-factor will be restored. Calling <code>plot_fit</code>, <code>report</code>, or <code>save</code> will act on that fit. To examine other fits from the sequence, the <code>restore</code> must be called using one of the results from the <code>combi_results</code> attribute.</p>

</dd>
<dt id="combi_report"><code>combi_report</code></dt>
<dd>

<p>Write an Excel or CSV (comma separated value) file that can be imported into a spreadsheet with the results of the combinatorial fit.</p>

<pre><code>  $lcf-&gt;combi_report(&quot;results.xls&quot;);</code></pre>

<p>The argument is the name of the output file (which you probably want to give a &quot;.csv&quot; or &quot;.xls&quot; extension so your spreadsheet will know to import it as such. The choice of file type is controlled by the value of the <code>lcf -&gt;; output</code> configuration parameter.</p>

<p>Note that care is taken to strip any commas from the names of the standards before writing the CSV file. Also note that this does not make the most elegant spreadsheet, but it is certainly functional and it certainly allows you to examine all of your results.</p>

</dd>
</dl>

<h1 id="SEQUENCE-FITTING">SEQUENCE FITTING</h1>

<p>These attributes and methods are specifically related to combinatorial fitting. A combinatorial fit is one in which all possible combinations (within certain constraints) are compared to the data.</p>

<h2 id="Attributes-for-combinatorial-fitting1">Attributes for combinatorial fitting</h2>

<dl>

<dt id="seq_results"><code>seq_results</code></dt>
<dd>

<p>This is an array of hashes, sorted by rfactor, containing all the results of fitting sequence.</p>

<p>Each hash in the array looks like this:</p>

<pre><code>  {
   Rfactor =&gt; Num,
   Chinu   =&gt; Num,
   Chisqr  =&gt; Num,
   Nvarys  =&gt; Num,
   Scaleby =&gt; Num,
   aaaaa   =&gt; [weight, dweight, e0, de0],
   bbbbb   =&gt; [weight, dweight, e0, de0],
   ....
  }</code></pre>

<p>A key like &quot;aaaaa&quot; is the group attribute of a Data object used in the fit. From this, the final state of each fit can be recovered using the <code>restore</code> method.</p>

</dd>
</dl>

<h2 id="Methods-of-sequence-fitting">Methods of sequence fitting</h2>

<dl>

<dt id="sequence"><code>sequence</code></dt>
<dd>

<p>Perform a sequence of fits to a group data.</p>

<pre><code>  $lcf-&gt;sequence(@data);</code></pre>

<p>The data in <code>$lcf</code> is appended to the beginning of <code>@data</code> unless the <code>include_caller</code> attribute is false. Care is taken to remove repeats from <code>@data</code>.</p>

<p>At the end of the fit, the <code>seq_results</code> attribute is filled with an array of hashes containing the results of each fit. This array is in the same order as <code>@data</code>.</p>

<p>At the end of the sequence of fits, the fit to the data originally in <code>$lcf</code> will be restored. Calling <code>plot_fit</code>, <code>report</code>, or <code>save</code> will act on that fit. To examine other fits from the sequence, the <code>restore</code> must be called using one of the results from the <code>seq_results</code> attribute.</p>

</dd>
<dt id="sequence_report"><code>sequence_report</code></dt>
<dd>

<p>Write an Excel or CSV (comma separated value) file that can be imported into a spreadsheet with the results of the combinatorial fit.</p>

<pre><code>  $lcf-&gt;sequence_report(&quot;results.csv&quot;);</code></pre>

<p>The argument is the name of the output file (which you probably want to give a &quot;.csv&quot; or &quot;.xls&quot; extension so your spreadsheet will know to import it as such. The choice of file type is controlled by the value of the <code>lcf -&gt;; output</code> configuration parameter.</p>

<p>Note that care is taken to strip any commas from the names of the standards before writing the CSV file. Also note that this does not make the most elegant spreadsheet, but it is certainly functional and it certainly allows you to examine all of your results.</p>

</dd>
<dt id="sequence_plot"><code>sequence_plot</code></dt>
<dd>

<p>Make a plot of the component weights as a function of data set.</p>

</dd>
</dl>

<h1 id="SERIALIZATION-AND-DESERIALIZATION">SERIALIZATION AND DESERIALIZATION</h1>

<p>Good question ...</p>

<h1 id="CONFIGURATION-AND-ENVIRONMENT">CONFIGURATION AND ENVIRONMENT</h1>

<p>See <a href="Config.pm.html">Demeter::Config</a> for a description of the configuration system. See the <code>lcf</code> configuration group for the relevant parameters.</p>

<h1 id="DEPENDENCIES">DEPENDENCIES</h1>

<p>Demeter&#39;s dependencies are in the <i>Build.PL</i> file.</p>

<h1 id="BUGS-AND-LIMITATIONS">BUGS AND LIMITATIONS</h1>

<ul>

<li><p>noise</p>

</li>
<li><p>Serialization and deserialization</p>

</li>
<li><p>linear term</p>

</li>
<li><p>better sanity method that provides usable feedback for a GUI</p>

</li>
<li><p>singlefile plot</p>

</li>
<li><p>further processing of LCF result (i.e. bkg removal, FTs). This seems better than converting the fit into a normal Data object</p>

</li>
</ul>

<p>Please report problems to the Ifeffit Mailing List (<a href="http://cars9.uchicago.edu/mailman/listinfo/ifeffit/">http://cars9.uchicago.edu/mailman/listinfo/ifeffit/</a>)</p>

<p>Patches are welcome.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Bruce Ravel, <a href="http://bruceravel.github.io/home">http://bruceravel.github.io/home</a></p>

<p><a href="http://bruceravel.github.io/demeter/">http://bruceravel.github.io/demeter/</a></p>

<h1 id="LICENCE-AND-COPYRIGHT">LICENCE AND COPYRIGHT</h1>

<p>Copyright (c) 2006-2018 Bruce Ravel (<a href="http://bruceravel.github.io/home">http://bruceravel.github.io/home</a>). All rights reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See <a href="http://metacpan.org/module/perlgpl">perlgpl</a>.</p>

<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

</div><div class="footer">generated by <a href="http://metacpan.org/module/Pod::ProjectDocs">Pod::ProjectDocs</a></div></body></html>

